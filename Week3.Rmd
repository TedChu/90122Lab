---
title: 'Week 3: Visualisation of Spatial Data--ggplot2'
---

<div style="margin-bottom:50px;">
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

</div>


```
The following materials are partly based on "https://eriqande.github.io/rep-res-eeb-2017/" 
by Eric C. Anderson, Kristen C. Ruegg, Tina Cheng.
```

# Introduction
* In this Lab, we will learn the following functions in ggplot2. 
  + ggplot
  + geom_point: draw points
  + geom_line: draw lines
  + geom_polygon: draw polygons
  + geom_sf: draw sf class


# ggplot2
According to wikipedia and R-project website (https://cran.r-project.org/web/packages/ggplot2/index.html). 

*ggplot2 is a data visualization package for the statistical programming language R. Created by Hadley Wickham in 2005, ggplot2 is an implementation of Leland Wilkinson's Gurky Gangâ€”a general scheme for data visualization which breaks up graphs into semantic components such as scales and layers. ggplot2 can serve as a replacement for the base graphics in R and contains a number of defaults for web and print display of common scales. Since 2005, ggplot2 has grown in use to become one of the most popular R packages.*

It is a general framework for data visualisation, and in this class, we will use it to visualise spatial data and spatio-temporal data. 

## pv dataset
The pv dataset includes information of  the history of pole-vaulting world record "http://en.wikipedia.org/wiki/Men's_pole_vault_world_record_progression". Here, the data is already stored in *pv.RData*. 

First, read the RData set. 
```{r, echo=TRUE, fig.width=6, fig.align="center"}

library(ggplot2)
load("datasets/pv.RData")
```

Here are some plots. 
```{r, echo=TRUE, fig.width=3, fig.height =3, fig.align="center"}
par(mfrow=c(1,3))      # This command will not work in ggplot2
## Tell ggplot the data, x variable and y variable
g <- ggplot(data = pv, aes(x = Date, y = Meters))
g    
## Add points
g2 = g + geom_point()
g2
## Add red lines
g3 <- g2 + geom_line(color = "red")
g3

## Change the color of a point by adding a more layer
g4 <- g3 + geom_point(data = pv[4,], color="red", fill = "blue", shape = 21, size = 4, stroke =2) 
g4  
```




* The best way to learn trying different codes and see what it plots. Here are some suggestions
  + ggplot()
  + ggplot(data = pv, aes(x = Date, y = Meters))
  + ggplot()+geom_point(data = pv, mapping = aes(x = Date, y = Meters),col=2)
  + For more details on specification, type *vignette("ggplot2-specs")*

* ggplot:  initialize the plotting and everything set up in *aes* is valid for all subsequent plots. 
  + Try g <- ggplot(data = pv, aes(x = Date, y = Meters, col = 3)), and repeat everything above. 
  + More details can be found https://www.datanovia.com/en/blog/ggplot-aes-how-to-assign-aesthetics-in-ggplot2/ 
  
* Add layers. 
  + geom_point: more example at https://ggplot2.tidyverse.org/reference/geom_point.html
  + geom_line: https://ggplot2.tidyverse.org/reference/geom_path.html?q=geom%20_%20lines#arguments


This part is to provide some interesting plots
```{r, echo=TRUE, fig.width=9, fig.height=3, fig.align="center"}
library(gridExtra)    # for the function grid.arrange
d <- ggplot(data = pv, aes(x = Date, y = Meters))
d2 <- d + geom_ribbon(aes(ymax = Meters), ymin = min(pv$Meters), alpha = 0.4, fill = "turquoise")
d3 <- d2 + geom_line(color = "blue")
d4 <- d3 + geom_point(color = "orange")
grid.arrange(d2, d3, d4, nrow = 1)
d5 <- d4 + geom_rug(sides = "bl", mapping = aes(color = Nation))
d5
```

For, *geom_ribbon*, try to see
```{r, echo=TRUE, fig.width=9, fig.height=3, fig.align="center"}
dr1 = d + geom_ribbon(aes(ymax = Meters), ymin = min(pv$Meters), fill = "grey70") + geom_line(aes(y = Meters))
dr2 = d + geom_ribbon(aes(ymin = Meters - 0.5, ymax = Meters + 0.5), fill = "grey70") + geom_line(aes(y = Meters))+ geom_point()
dr3 = d + geom_ribbon(aes(ymin = Meters), ymax = max(pv$Meters), fill = "grey70") + geom_line(aes(y = Meters))
grid.arrange(dr1, dr2, dr3, nrow = 1)
```






\newpage

# ggplot for spatial data

R package *maps* and *mapdata* provide some maps. 

## USA map
We will use the USA map
```{r, echo=TRUE, fig.width=6, fig.align="center"}
library(maps)
library(mapdata)
library(sp)
usa <- map_data("usa")
dim(usa)
head(usa)
tail(usa)
```

First, we plot usa map
```{r, echo=TRUE, fig.width=10, fig.align="center"}
gg0 = ggplot() + geom_polygon(data = usa, aes(x=long, y = lat, group = group)) + 
  coord_fixed(1.3)
gg1 <- ggplot() + 
  geom_polygon(data = usa, aes(x=long, y = lat, group = group), fill = "violet", color = "blue") + 
  coord_fixed(1.3)
labs <- data.frame(
  long = c(-122.064873, -122.306417),
  lat = c(36.951968, 47.644855),
  names = c("SWFSC-FED", "NWFSC"),
  stringsAsFactors = FALSE
)  
gg2 = gg1 + 
  geom_point(data = labs, aes(x = long, y = lat), color = "yellow", size = 2)

grid.arrange(gg0, gg1, gg2, nrow = 1)
```

* Key points
  + "group = group" is essential, you can try code without the group argument
  + coord_fixed(): It fixes the relationship between one unit in the y direction and one unit in the x direction. 



## US state
```{r, echo=TRUE, fig.width=10, fig.align="center"}
### Draw plots for all USA States
states <- map_data("state")
ggplot(data = states) + 
  geom_polygon(aes(x = long, y = lat, fill = region, group = group), color = "white") + 
  coord_fixed(1.3) +
  guides(fill=FALSE) 

### Draw a subset of USA states
### Use function subset to select states. 
west_coast <- subset(states, region %in% c("california", "oregon", "washington"))
ggplot(data = west_coast) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "palegreen", color = "black") + 
  coord_fixed(1.3)
```

Can you tell the difference between *color* and *fill* argument? 


# sf class 

Here, *sf*(simple feature) is a type of data class. First, we use package *sf* to read shapefiles. 
For more details, see https://cran.r-project.org/web/packages/sf/vignettes/sf1.html

## Shapefile

* A shapefile is a simple, nontopological format for storing the geometric location and attribute information of geographic features. It is developed by Esri (Environmental Systems Research Institute, the company makes famous ArcGIS software). It usually includes the following file
  + .shp:  	geometries
  + .shx:  	an index file to the geometries
  + .dbf:	  storing attribute data

The shapefile is downloaded from https://www.igismap.com/australia-shapefile-download/ (This website also has shapefile of other Australia regions and cities). You can download all LGA in Victoria through  https://data.gov.au/dataset/ds-dga-bdf92691-c6fe-42b9-a0e2-a4cd716fa811/details (However, it does not indicate which LGA belongs to Greater Melbourne). 

* The shapefile here is named *Aus-Melbourne02*, which records information from all LGA in Greater Melbourne. Here is some extra information: 
  + All datasets can be downloaded at https://github.com/TedChu/90122Lab/tree/master/datasets. 
  + First, set the working directory through *setwd*. Remember you need to use forward slash (/) or double slash (\\\\), but Not back slash (\\).
  + I will not recommend you to have space between your folder titles. That is, to write *setwd("..../90122Lab")*, Not *setwd("..../90122 Lab")*
  + As indicated below, all my files (*Aus-Melbourne02.shp*, *Aus-Melbourne02.dbf*, *Aus-Melbourne02.prj* and *Aus-Melbourne02.shx*) are stored at C:\\Users\\tingjinc\\OneDrive - The University of Melbourne\\Documents\\GitFile\\90122Lab\\datasets\\Mel
  + Depending on where you store your files, you need to adjust directories in *setwd* and *dsn*. 

```{r, echo=TRUE, fig.width=6, fig.align="center", message = FALSE}
library(sf)
setwd("~/Dropbox/2_MAST90122/90122LabGit")
gmel = st_read(dsn = "datasets/Mel/Aus-Melbourne02.shp", "Aus-Melbourne02")
```


The object *gmel* belongs to a *sf* class, which extends a *data.frame*. Note that the last column is called *geometry*, which stores the shape of the region. 
```{r, echo=TRUE, fig.width=6, fig.align="center"}
class(gmel) 
print(gmel[1:3], n = 3)
```

## Manuplation of sf object


You can manipulate the *sf* object similar to a *data.frame* object. Here, I want to remove the first element since it is greater melbourne, not LGA. 
```{r, echo=TRUE, fig.width=6, fig.align="center"}
gmel = gmel[-1,]  # the first element is greater melbourne, not LGA
```

R package *mapview* provides functions to create interactive visualisation of spatial data.(For more detailed tutorial, please look at "https://r-spatial.github.io/mapview/index.html").  
A simple interactive map can generated as
```{r, echo=TRUE, fig.width=10, fig.align="center"}
library(mapview)
mapView(gmel)
```

Variables
```{r, echo=TRUE, fig.width=6, fig.align="center"}
gmel$name                  # Extracting a variable
gmel$ID = 1:31              # Add a new variable
gmel$ID = NULL              # Delete a variable
```

Select LGA == City of Banyule is 
```{r, echo=TRUE, fig.width=6, fig.align="center"}
i = which(gmel$name == "City of Banyule")
g = gmel[i, ]
mapView(g)
```


## Combining Data (Optional)


In https://discover.data.vic.gov.au/dataset/2015-local-government-area-profiles, many statistics for each LGA in Victoria is recorded on 2015, and it is available in *LGAData.csv*. It includes around 400 variables. 

* Here, we choose
  + name: LGA name
  + price: median house price
  + dis: distance to Melbourne (in km)
  + off: totoal offences per 1000 population
  + inc: median household income weekly


```{r, echo=TRUE, fig.width=6, fig.align="center"}
LGAData = read.csv("datasets/LGAData.csv")
LGAsub = subset(LGAData, select = c("LGA.Name","Median.house.price", "Distance.to.Melbourne", "Total.offences.per.1.000.population", "Median.household.income"))
colnames(LGAsub) = c("name","price", "dis", "off", "inc")
```

We want to combine the data in *LGAsub* and *gmel* together. However, the use different names. For example, in *LGAsub*, it says "City of Banyule", while it says "Banyule (C)" in *gmel*. We want to add a new variable *name2*, and for the above LGA, it will be named "Banyule".  Therefore, *LGAsub* and *gmel* will be matched and joined. 
```{r, echo=TRUE, fig.width=6, fig.align="center"}
# Add name2 for gmel
gmel$name2 = NA
for (i in 1:length(gmel$name)){
  lganame = as.character(gmel$name[i])
  gmel$name2[i] = (strsplit(lganame," of ")[[1]])[2]
}

LGAsub$price = as.numeric(gsub('[$,]', '', LGAsub$price))  # Change price from dollar form to numbers
LGAsub$inc = as.numeric(gsub('[$,]', '', LGAsub$inc))       # Change income from dollar form to numbers
LGAsub$dis = as.numeric(gsub(" km", "", LGAsub$dis))       # distance to numeric

# Add name2 for LGAsub
LGAsub$name2 = NA
for (i in 1:dim(LGAsub)[1]){
  lganame = as.character(LGAsub$name[i])
  LGAsub$name2[i] = substr(lganame, 1, nchar(lganame)-4)
}

## I only want to select some variables from gmel
temdata = subset(gmel, select = c("name", "name2"))

## Join two objects
library(dplyr)
gmel2 = left_join(temdata, LGAsub, by = "name2")


# Save the datasets
save(gmel2, file = "datasets/gmel2.Rdata")   
```



\vspace{100pt}




## Package sf


An alternative (and better) way for visualization of spatial objects in ggplot2 is to use *geom_sf* function. 






```{r, echo=TRUE, fig.width=6, fig.align="center", warning = FALSE}
library(ggplot2)
ggplot()+geom_sf(data=gmel2, aes(fill = price))

```

* In summary, we focus on two ways to visulization
  + spplot:    work for SpatialPolygonsDataFrame
  + geom_sf:   work for sf class
  + mapView:   work for both SpatialPolygonsDataFrame and sf class

```{r, echo=TRUE, fig.width=6, fig.align="center"}
library(mapview)
mapView(gmel2, zcol = "price")
```
