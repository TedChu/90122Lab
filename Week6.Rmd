---
title: 'Week 6: Visualisation of Spatial Data -- Maps'
---

<div style="margin-bottom:50px;">
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

</div>



# Introduction
* In this Lab, we will learn to draw some maps. 





# USA map
R package *maps* and *mapdata* provide some maps. We will use them for the USA map
```{r, echo=TRUE, fig.width=6, fig.align="center", warning = F, message = F}
library(ggplot2)
library(sf)
library(maps)
library(mapdata)
library(sp)
usa <- map_data("usa")
dim(usa)
head(usa)
tail(usa)
```

First, we plot usa map
```{r, echo=TRUE, fig.width=10, fig.align="center"}
library(gridExtra)
gg0 = ggplot() + geom_polygon(data = usa, aes(x=long, y = lat, group = group)) + 
  coord_fixed(1.3)
gg1 <- ggplot() + 
  geom_polygon(data = usa, aes(x=long, y = lat, group = group), fill = "violet", color = "blue") + 
  coord_fixed(1.3)
labs <- data.frame(
  long = c(-122.064873, -122.306417),
  lat = c(36.951968, 47.644855),
  names = c("SWFSC-FED", "NWFSC"),
  stringsAsFactors = FALSE
)  
gg2 = gg1 + 
  geom_point(data = labs, aes(x = long, y = lat), color = "yellow", size = 2)

grid.arrange(gg0, gg1, gg2, nrow = 1)
```

* Key points
  + "group = group" is essential, you can try code without the group argument
  + coord_fixed(): It fixes the relationship between one unit in the y direction and one unit in the x direction. 



## US state
```{r, echo=TRUE, fig.width=10, fig.align="center", warning = F}
### Draw plots for all USA States
states <- map_data("state")
ggplot(data = states) + 
  geom_polygon(aes(x = long, y = lat, fill = region, group = group), color = "white") + 
  coord_fixed(1.3) + guides(fill=FALSE) 

### Draw a subset of USA states
### Use function subset to select states. 
west_coast <- subset(states, region %in% c("california", "oregon", "washington"))
ggplot(data = west_coast) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "palegreen", color = "red") + 
  coord_fixed(1.3)
```

Can you tell the difference between *color* and *fill* argument? 





# Victoria maps

* Most shapefile can found in https://data.gov.au. 
+ All LGA: VICLGA folder -- 92 elements
+ All suburb: VICSub folder  -- 2973 elements
+ LGA in Greater Melbourne -- 32 element (1st element is greater melbourne)

All datasets are read into as *sf* objects
```{r, echo=TRUE, fig.width=6, fig.align="center", message = F}
library(sf)
VICLGA = st_read(dsn = "datasets/VICLGA/VIC_LOCALITY_POLYGON_shp.shp", "VIC_LOCALITY_POLYGON_shp")
VICSub = st_read(dsn="datasets/VICSub/VIC_LOCALITY_POLYGON_shp.shp", "VIC_LOCALITY_POLYGON_shp")
MELLGA = st_read(dsn = "datasets/Mel/Aus-Melbourne02.shp", "Aus-Melbourne02")
```



First, we make sure that all *sf* objects has the same CRS
```{r, echo=TRUE, fig.width=6, fig.align="center", message = F}
## Retrieve CRS
st_crs(VICLGA) 
st_crs(VICSub)
st_crs(MELLGA)

## Transform crs system to WGS84(epsg: 4326)
VICLGA <- st_transform(VICLGA, 4326)
VICSub <- st_transform(VICSub, 4326)
st_crs(VICLGA) 
st_crs(VICSub)
```

Second, we want to obtain all suburbs in City of Melbourne. Note that we already have all suburbs in Victoria, and we also know the boundary of City of Melbourne from VICLGA or MELLGA. We only need to ``cut" all suburbs from *VICSub* using boundary of City of Melbourne. 

* One useful funciton in *st_intersection* in package *sf*
  + st_intersection(x, y)
  + crop returns a geographic subset of an object *x* as specified by an Extent object *y*

```{r, echo=TRUE, fig.width=6, fig.align="center", message = FALSE}
library(raster)
library(mapview)


## Obtain all suburbs in City of Melbourne (including part of suburb)
i = which(VICLGA$VIC_LGA__3 == "BANYULE")
CMEL = VICLGA[i, ]
tmp = st_intersection(VICSub, CMEL)
mapView(tmp)
```


The map appears OK, but a closer look shows that some suburb are not supposed to be there (e.g. Eltham). Here is a list of all suburbs in City of Banyule (https://en.wikipedia.org/wiki/City_of_Banyule). The reason for this is likely due to the different resolution and accuracy of shapefiles (VICSub and VICLGA).  

```{r, echo=TRUE, fig.width=6, fig.align="center", message = FALSE}
## Obtain all suburbs in City of Melbourne (including part of suburb)
tmp$area = st_area(tmp)
BSub = tmp[as.numeric(tmp$area) > 100000,]
mapView(BSub)
```


