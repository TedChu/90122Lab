---
title: 'Week 5: Moran''s I, LISA'
---

<div style="margin-bottom:50px;">
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

</div>

# Introduction

* In this lab, you will learn 
  + Creating weight matrix
  + Conducting Moran's I and LISA


# Create Weight Matrix

The dataset is *gmel2*, and it can be downloaded at https://github.com/TedChu/90122Lab/tree/master/datasets.
```{r, echo=TRUE, fig.width=10, fig.align="center", message = FALSE}
library(spdep)
load("datasets/gmel2.Rdata")
```



R function *poly2nb* produces a spatial weight matrix from a SpatialPolygons(DataFrame) object. 
```{r, echo=TRUE, fig.width=5, fig.height =5, fig.align="center"}
## Convert gmel2 to SpatialPolygonsDataFrame, since the following packages require SpatialPolygonsDataFrame
gmel.sp = as(gmel2, "Spatial")
Wqueen = poly2nb(gmel.sp)
Wrook = poly2nb(gmel.sp, queen=FALSE)
plot(gmel.sp,border="grey60", axes=TRUE)
plot(Wqueen, coordinates(gmel.sp), pch=19, cex=0.6, add=TRUE,col="red")
plot(Wrook, coordinates(gmel.sp), pch=19, cex=0.6, add=TRUE)
```

* There are three potential class for spatial weight matrix: *nb* (neighborhood) class, *mat* (matrix) class, and *listw* class.
  + They all store the same information, but in different formats.
  + Different functions may require different formats. For example, *moran.test* requires the  *listw* class. You can find these information in help files of these functions.
  + Functions to transform between these three formats: *nb2listw*, *nb2mat*, *mat2nb*, etc. 


Can you see the difference between *queen* rule and *rook* rule?


# Moran's I test
A Moran's I test is performed on the variable *price*. More information about Moran's I codes can be found in Cp1C -- 8. 


```{r, echo=TRUE, fig.align="center"}
## plot
moran.test(x=gmel2$price, nb2listw(Wqueen), alternative="two.sided")
```

Since the p-value < 0.05, we conclude that there is spatial autocorrelation for the house price in Greater Melbourne.  


* Comments
  + The function requires *listw* form for spatial weight matrix
  + Argument *alternative*
    + What will you do if the alternative test is "There is positive spatial autocorrelation".
  + The above test is *Moran I test under randomisation*. 
    + What does this mean?
    + If you want to take analytical approach mentioned in lectures, what should you do?
    
    
# LISA

LISA is performed on *price* variable. 
```{r, echo=TRUE, fig.width=3, fig.height =3, fig.align="center"}
resI = localmoran(gmel2$price, nb2listw(Wqueen), alternative="two.sided")
round(head(resI),3)
```
* For the lisa output
  + First column: the value of local moran's I
  + Second column: the expected value (which is $-1/(n-1)$)
  + Third column: the variance of local moran's I
  + Fourth column $=\frac{(Ii - E.Ii)}{\sqrt{Var.Ii}}$
  + Fifth column: the p-value. 

&nbsp;

Next, some visualisation for the above results. 
```{r, echo=TRUE, fig.width=3, fig.height =3, fig.align="center",warning = F}
####
gmellisa = gmel2
gmellisa$lisa = resI[,1]
gmellisa$pvalue = resI[,5]
### Spatial plots with LISA value
library(ggplot2)
ggplot() + geom_sf(data=gmellisa, aes(fill = lisa))

ggplot() + geom_sf(data=gmellisa, aes(fill = pvalue))
```

Suppose we want to know which LGAs have significant local spatial autocorrelation ($\alpha = 0.05$). 

```{r, echo=TRUE, fig.width=3, fig.height =3, fig.align="center",warning = F}
gmellisa$name2[gmellisa$pvalue < 0.05]
```


They all have positive LISA values. If you want to formally test whether there are positive local autocorrelation, you will need to change *alternative* to *greater*.



